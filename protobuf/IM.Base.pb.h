// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Base.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_IM_2eBase_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_IM_2eBase_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_IM_2eBase_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_IM_2eBase_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_IM_2eBase_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace IM {
namespace Base {

enum ServiceID : int {
  SID_DEFAULT = 0,
  SID_LOGIN = 1,
  ServiceID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServiceID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServiceID_IsValid(int value);
constexpr ServiceID ServiceID_MIN = SID_DEFAULT;
constexpr ServiceID ServiceID_MAX = SID_LOGIN;
constexpr int ServiceID_ARRAYSIZE = ServiceID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceID_descriptor();
template<typename T>
inline const std::string& ServiceID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceID_descriptor(), enum_t_value);
}
inline bool ServiceID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceID>(
    ServiceID_descriptor(), name, value);
}
enum LoginCmdID : int {
  CID_LOGIN_RQ_DEFAULT = 0,
  CID_LOGIN_RQ_SERVER = 1,
  CID_LOGIN_RS_SERVER = 2,
  CID_LOGIN_RQ_USERLOGIN = 3,
  CID_LOGIN_RS_USERLOGIN = 4,
  CID_LOGIN_RQ_LOGOUT = 5,
  CID_LOGIN_RS_LOGOUT = 6,
  CID_LOGIN_KICK_USER = 7,
  CID_LOGIN_RQ_DEVICETOKEN = 8,
  CID_LOGIN_RS_DEVICETOKEN = 9,
  CID_LOGIN_RQ_KICK_PC_CLIENT = 10,
  CID_LOGIN_RS_KICK_PC_CLIENT = 11,
  CID_LOGIN_RQ_PUSH_SHIELD = 12,
  CID_LOGIN_RS_PUSH_SHIELD = 13,
  CID_LOGIN_RQ_QUERY_PUSH_SHIELD = 14,
  CID_LOGIN_RS_QUERY_PUSH_SHIELD = 15,
  LoginCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LoginCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LoginCmdID_IsValid(int value);
constexpr LoginCmdID LoginCmdID_MIN = CID_LOGIN_RQ_DEFAULT;
constexpr LoginCmdID LoginCmdID_MAX = CID_LOGIN_RS_QUERY_PUSH_SHIELD;
constexpr int LoginCmdID_ARRAYSIZE = LoginCmdID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginCmdID_descriptor();
template<typename T>
inline const std::string& LoginCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginCmdID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoginCmdID_descriptor(), enum_t_value);
}
inline bool LoginCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginCmdID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginCmdID>(
    LoginCmdID_descriptor(), name, value);
}
enum ClientType : int {
  CLIENT_TYPE_DEFAULT = 0,
  CLIENT_TYPE_WINDOWS = 1,
  CLIENT_TYPE_MAC = 2,
  CLIENT_TYPE_LINUX = 3,
  CLIENT_TYPE_ANDROID = 4,
  CLIENT_TYPE_IOS = 5,
  ClientType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClientType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClientType_IsValid(int value);
constexpr ClientType ClientType_MIN = CLIENT_TYPE_DEFAULT;
constexpr ClientType ClientType_MAX = CLIENT_TYPE_IOS;
constexpr int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientType_descriptor();
template<typename T>
inline const std::string& ClientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientType_descriptor(), enum_t_value);
}
inline bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum UserStatus : int {
  USER_STATUS_DEFAULT = 0,
  USER_STATUS_ONLINE = 1,
  USER_STATUS_BUSY = 2,
  USER_STATUS_OFFLINE = 3,
  USER_STATUS_LEAVE = 4,
  UserStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserStatus_IsValid(int value);
constexpr UserStatus UserStatus_MIN = USER_STATUS_DEFAULT;
constexpr UserStatus UserStatus_MAX = USER_STATUS_LEAVE;
constexpr int UserStatus_ARRAYSIZE = UserStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserStatus_descriptor();
template<typename T>
inline const std::string& UserStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserStatus_descriptor(), enum_t_value);
}
inline bool UserStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserStatus>(
    UserStatus_descriptor(), name, value);
}
enum MsgType : int {
  MSG_TYPE_DEFAULT = 0,
  MSG_TYPE_SINGLE_TEXT = 1,
  MSG_TYPE_SINGLE_AUDIO = 2,
  MSG_TYPE_SINGLE_VIDEO = 3,
  MSG_TYPE_SINGLE_PHOTO = 4,
  MSG_TYPE_GROUP_AUDIO = 5,
  MSG_TYPE_GROUP_VIDEO = 6,
  MSG_TYPE_GROUP_PHOTO = 7,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = MSG_TYPE_DEFAULT;
constexpr MsgType MsgType_MAX = MSG_TYPE_GROUP_PHOTO;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace Base
}  // namespace IM

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::IM::Base::ServiceID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::Base::ServiceID>() {
  return ::IM::Base::ServiceID_descriptor();
}
template <> struct is_proto_enum< ::IM::Base::LoginCmdID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::Base::LoginCmdID>() {
  return ::IM::Base::LoginCmdID_descriptor();
}
template <> struct is_proto_enum< ::IM::Base::ClientType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::Base::ClientType>() {
  return ::IM::Base::ClientType_descriptor();
}
template <> struct is_proto_enum< ::IM::Base::UserStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::Base::UserStatus>() {
  return ::IM::Base::UserStatus_descriptor();
}
template <> struct is_proto_enum< ::IM::Base::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::Base::MsgType>() {
  return ::IM::Base::MsgType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_IM_2eBase_2eproto
